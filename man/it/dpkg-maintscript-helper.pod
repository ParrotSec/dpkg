
        *****************************************************
        *           GENERATED FILE, DO NOT EDIT             *
        * THIS IS NO SOURCE FILE, BUT RESULT OF COMPILATION *
        *****************************************************

This file was generated by po4a(7). Do not store it (in VCS, for example),
but store the PO file used as source file by po4a-translate.

In fact, consider this as a binary, and the PO file as a regular .c file:
If the PO get lost, keeping this translation up-to-date will be harder.

=encoding UTF-8

=head1 NOME

dpkg-maintscript-helper - aggira limiti noti di dpkg negli script del
manutentore

=head1 SINTASSI

B<dpkg-maintscript-helper> I<comando> [I<parametro>...] B<-->
I<parametro-script-manut>...

=head1 COMANDI E PARAMETRI

=over 

=item B<supports> I<comando>

=item B<rm_conffile> I<fileconf> [I<versione-prec> [I<pacchetto>]]

=item B<mv_conffile> I<vecchio-fileconf> I<nuovo-fileconf> [I<versione-prec>
[I<pacchetto>]]

=item B<symlink_to_dir> I<percorso> I<vecchia-destinaz> [I<versione-prec>
[I<pacchetto>]]

=item B<dir_to_symlink> I<percorso> I<nuova-destinaz> [I<versione-prec>
[I<pacchetto>]]

=back

=head1 DESCRIZIONE

Questo programma è progettato per essere eseguito dall'interno di script dei
manutentori per effettuare alcuni compiti che B<dpkg> non può (ancora)
gestire in modo nativo a causa di decisioni progettuali oppure per
limitazioni attuali.

Molti di questi compiti richiedono azioni coordinate da parte di diversi
script dei manutentori (B<preinst>, B<postinst>, B<prerm>, B<postrm>). Per
evitare sbagli basta mettere la stessa chiamata in tutti gli script e il
programma adatterà automaticamente il suo comportamento sulla base della
variabile d'ambiente B<DPKG_MAINTSCRIPT_NAME> e sugli argomenti per gli
script dei manutentori che devono essere passati dopo un doppio trattino.

=head1 PARAMETRI COMUNI

=over 

=item I<versione-prec>

Definisce la più recente versione del pacchetto il cui aggiornamento
dovrebbe attivare l'operazione. È importante calcolare correttamente il
valore di I<versione-prec> in modo che le operazioni siano effettuate in
modo corretto anche se l'utente ha ricompilato il pacchetto con una versione
locale. Se I<versione-prec> è vuota o viene omessa, allora l'operazione
viene tentata ad ogni aggiornamento (notare: è più sicuro fornire la
versione e far sì che l'operazione venga tentata una sola volta).

Se il file di configurazione non è stato fornito per diverse versioni, e si
sta ora cercando di modificare gli script del manutentore per ripulire il
file obsoleto, I<versione-prec> dovrebbe essere basata sulla versione del
pacchetto che si sta preparando ora, non sulla prima versione del pacchetto
a cui mancava il file di configurazione. Ciò è vero similmente per tutte le
altre azioni.

Per esempio, per un file di configurazione rimosso nella versione B<2.0-1>
di un pacchetto, I<versione-prec> dovrebbe essere impostata a B<2.0-1~>. Ciò
farà sì che il file di configurazione sia rimosso anche se l'utente ha
ricompilato la versione precedente B<1.0-1> come B<1.0-1local1>. Oppure un
pacchetto che passa un percorso da un collegamento simbolico (fornito nella
versione B<1.0-1>) ad una directory (fornita nella versione B<2.0-1>), ma
che effettua l'effettivo cambiamento nello script del manutentore nella
versione B<3.0-1>, dovrebbe impostare I<versione-prec> a B<3.0-1~>.

=item B<pacchetto>

The package name owning the pathname(s).  When the package is “Multi-Arch:
same” this parameter must include the architecture qualifier, otherwise it
should B<not> usually include the architecture qualifier (as it would
disallow cross-grades, or switching from being architecture specific to
architecture B<all> or vice versa).  If the parameter is empty or omitted,
the B<DPKG_MAINTSCRIPT_PACKAGE> and B<DPKG_MAINTSCRIPT_ARCH> environment
variables (as set by B<dpkg> when running the maintainer scripts) will be
used to generate an arch-qualified package name.

=item B<-->

Tutti i parametri degli script dei manutentori devono essere passati al
programma dopo B<-->.

=back

=head1 COMPITI RELATIVI AI FILE DI CONFIGURAZIONE

Quando aggiorna un pacchetto, B<dpkg> non rimuoverà automaticamente un file
di configurazione (un file di configurazione per il quale B<dpkg> dovrebbe
preservare i cambiamenti dell'utente) se non è presente nella versione più
nuova. Ci sono due ragioni principali per questo comportamento. La prima è
che il file di configurazione potrebbe essere stato tolto per sbaglio e la
successiva versione potrebbe ripristinarlo e gli utenti non vorrebbero
vedere le proprie modifiche buttate al vento. La seconda è di permettere ai
pacchetti di transitare file da un file di configurazione mantenuto da dpkg
a un file mantenuto dagli script del manutentore del pacchetto, solitamente
con uno strumento come debconf o ucf.

Ciò significa che se un pacchetto deve rinominare o rimuovere un file di
configurazione, deve farlo esplicitamente e B<dpkg-maintscript-helper> può
essere usato per implementare in modo pulito la cancellazione e lo
spostamento di file di configurazione all'interno di script dei manutentori.

=head2 Rimozione di un file di configurazione

Se un file di configurazione viene completamente rimosso, dovrebbe essere
rimosso dal disco a meno che l'utente non l'abbia modificato. Se ci sono
modifiche locali, queste dovrebbero essere preservate. Se l'aggiornamento
del pacchetto fallisce, il file di configurazione appena reso obsoleto non
dovrebbe sparire.

Tutto ciò è implementato mettendo il seguente frammento shell negli script
del manutentore B<preinst>, B<postinst> e B<postrm>.

=over 

Z<>
 dpkg-maintscript-helper rm_conffile \
    I<conffile> I<prior-version> I<package> -- "$@"

=back

I<fileconf> è il nome del file di configurazione da rimuovere.

Attuale implementazione: in B<preinst>, controlla se il file di
configurazione è stato modificato e lo rinomina in
I<fileconf>B<.dpkg-remove> (se non modificato) o I<fileconf>B<.dpkg-backup>
(se modificato). In B<postinst>, quest'ultimo file viene rinominato in
I<fileconf>B<.dpkg-bak> e mantenuto per riferimento dato che contiene le
modifiche dell'utente ma il primo viene rimosso. Se l'aggiornamento del
pacchetto fallisce, B<postrm> reinstalla il file di configurazione
originale. Durante l'eliminazione completa, B<postrm> elimina anche il file
B<.dpkg-bak> fino ad allora preservato.

=head2 Rinominare un file di configurazione

Se un file di configurazione viene spostato da una posizione ad un'altra, è
necessario assicurarsi di spostare qualsiasi modifica fatta
dall'utente. Questo può sembrare a prima vista un semplice cambiamento dello
script B<preinst>, tuttavia ciò avrebbe come risultato che B<dpkg>
chiederebbe all'utente di approvare le modifiche al file di configurazione
anche se egli non ne è responsabile.

Un cambio di nome pulito può essere implementato mettendo il seguente
frammento shell negli script del manutentore B<preinst>, B<postinst> e
B<postrm>.

=over 

Z<>
 dpkg-maintscript-helper mv_conffile \
    I<old-conffile> I<new-conffile> I<prior-version> I<package> -- "$@"

=back

I<vecchio-fileconf> e I<nuovo-fileconf> sono il nome vecchio e quello nuovo
del file di configurazione da rinominare.

Attuale implementazione: B<preinst> controlla se il file di configurazione è
stato modificato; se lo è stato viene lasciato al suo posto altrimenti viene
rinominato in I<vecchio-fileconf>B<.dpkg-remove>. Durante la configurazione,
B<postinst> rimuove I<vecchio-fileconf>B<.dpkg-remove> e rinomina
I<vecchio-fileconf> in I<nuovo-fileconf> se I<vecchio-fileconf> è ancora
disponibile. In caso di aggiornamento o installazione falliti, B<postrm>
rinomina I<vecchio-fileconf>B<.dpkg-remove> nuovamente in
I<vecchio-fileconf>, se necessario.

=head1 CAMBIAMENTI A COLLEGAMENTI SIMBOLICI E DIRECTORY

Quando si aggiorna un pacchetto, B<dpkg> non modifica automaticamente un
collegamento simbolico in una directory o viceversa. Le retrocessioni di
versione non sono supportate e il percorso verrà lasciato come è.

=head2 Passare da un collegamento simbolico ad una directory

Se si passa da un collegamento simbolico ad una directory reale, è
necessario assicurarsi prima dello spacchettamento che il collegamento
simbolico venga rimosso. Ciò può sembrare a prima vista una semplice
modifica allo script B<preinst>, tuttavia ciò risulterebbe in alcuni
problemi nel caso di personalizzazioni locali dell'amministratore sul
collegamento simbolico o in caso di retrocessione del pacchetto.

Un cambio di nome pulito può essere implementato mettendo il seguente
frammento shell negli script del manutentore B<preinst>, B<postinst> e
B<postrm>.

=over 

Z<>
 dpkg-maintscript-helper symlink_to_dir \
    I<pathname> I<old-target> I<prior-version> I<package> -- "$@"

=back

I<percorso> è il nome assoluto del vecchio collegamento simbolico (il
percorso sarà una directory al termine dell'installazione) e
I<vecchia-destinaz> è il nome della destinazione del vecchio collegamento
simbolico I<percorso>. Può essere sia assoluto sia relativo alla directory
che contiene I<percorso>.

Attuale implementazione: B<preinst> controlla se il collegamento simbolico
esiste e punta a I<vecchia-destinaz>, se non è così allora viene lasciato al
suo posto, altrimenti viene rinominato in
I<percorso>B<.dpkg-backup>. Durante la configurazione B<postinst> rimuove
I<percorso>B<.dpkg-backup> se questo è ancora un collegamento simbolico. In
caso di aggiornamento o installazione falliti, B<postrm> rinomina
I<percorso>B<.dpkg-backup> nuovamente in I<percorso> se necessario.

=head2 Passare da una directory a un collegamento simbolico

Se si passa da una directory reale a un collegamento simbolico, è necessario
assicurarsi prima dello spacchettamento che la directory venga rimossa. Ciò
può sembrare a prima vista una semplice modifica allo script B<preinst>,
tuttavia ciò risulterebbe in alcuni problemi nel caso in cui la directory
contenga file di configurazione, nomi di percorso di proprietà di altri
pacchetti, nomi di percorso creati localmente, oppure in caso di
retrocessione del pacchetto.

Un passaggio pulito può essere implementato mettendo il seguente frammento
shell negli script del manutentore B<preinst>, B<postinst> e B<postrm>.

=over 

Z<>
 dpkg-maintscript-helper dir_to_symlink \
    I<pathname> I<new-target> I<prior-version> I<package> -- "$@"

=back

I<percorso> è il nome assoluto della vecchia directory (il percorso sarà un
collegamento simbolico al termine dell'installazione) e I<nuova-destinaz> è
il nome del nuovo collegamento simbolico I<percorso>. Può essere sia
assoluto sia relativo alla directory che contiene I<percorso>.

Attuale implementazione: B<preinst> controlla se la directory esiste, non
contiene file di configurazione, percorsi di proprietà di altri pacchetti o
percorsi creati localmente; se non è così è lasciata al suo posto,
altrimenti viene rinominata in I<percorso>B<.dpkg-backup> e viene creata una
nuova directory vuota chiamata I<percorso> marcata con un file in modo che
dpkg possa tenerne traccia. Durante la configurazione B<postinst> finisce il
passaggio se I<percorso>B<.dpkg-backup> è ancora una directory e I<percorso>
è la directory contrassegnata; rimuove il file che contrassegna la
directory, muove i file appena creati all'interno della directory
contrassegnata nella destinazione del collegamento simbolico
I<nuova-destinaz>/, sostituisce la directory contrassegnata I<percorso> ora
vuota con un collegamento simbolico a I<nuova-destinaz> e rimuove
I<percorso>B<.dpkg-backup>. in caso di aggiornamento o installazione
falliti, B<postrm> rinomina I<percorso>B<.dpkg-backup> nuovamente in
I<percorso> se necessario.

=head1 INTEGRAZIONE NEI PACCHETTI

Quando si usa uno strumento di aiuto alla pacchettizzazione, controllare se
ha l'integrazione nativa con B<dpkg-maintscript-helper>, che può rendere la
vita più semplice. Vedere ad esempio B<dh_installdeb>(1).

Dato che B<dpkg-maintscript-helper> viene usato in B<preinst>, il suo uso
incondizionato richiede una pre-dipendenza per assicurare che sia stata già
spacchettata la versione richiesta di B<dpkg>. La versione richiesta dipende
dal comando usato: per B<rm_conffile> e B<mv_conffile> è 1.15.7.2, per
B<symlink_to_dir> e B<dir_to_symlink> è 1.17.14:

=over 

 Pre-Depends: dpkg (>= 1.17.14)

=back

In molti casi però l'operazione effettuata dal programma non è critica per
il pacchetto e invece di usare una pre-dipendenza si può chiamare il
programma solo se si sa che il comando richiesto è supportato dalla versione
di B<dpkg> attualmente installata:

=over 

Z<>
 if dpkg-maintscript-helper supports I<command>; then
    dpkg-maintscript-helper I<command> ...
 fi

=back

Il comando B<supports> restituisce 0 in caso di successo e 1 altrimenti. Il
comando B<supports> controlla se le variabili d'ambiente impostate da dpkg e
richiesta dallo script sono presenti e considera un fallimento se l'ambiente
non è sufficiente.

=head1 AMBIENTE

=over 

=item B<DPKG_ROOT>

If set, it will be used as the filesystem root directory.

=item B<DPKG_ADMINDIR>

If set, it will be used as the B<dpkg> data directory.

=item B<DPKG_COLORS>

Sets the color mode (since dpkg 1.19.1).  The currently accepted values are:
B<auto> (default), B<always> and B<never>.

=back

=head1 VEDERE ANCHE

B<dh_installdeb>(1).

